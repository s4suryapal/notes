import { useState, useMemo, useCallback } from 'react';
import { View, Text, StyleSheet, FlatList, TouchableOpacity, Alert, RefreshControl, Modal, Pressable, useWindowDimensions } from 'react-native';
import { useSafeAreaInsets } from 'react-native-safe-area-context';
import { router } from 'expo-router';
import { createMaterialTopTabNavigator } from '@react-navigation/material-top-tabs';
import { Menu, Search as SearchIcon, Grid2x2 as Grid, List, ArrowUpDown, Check } from 'lucide-react-native';
import { LinearGradient } from 'expo-linear-gradient';
import { Colors, Spacing, Typography, BorderRadius, Shadows } from '@/constants/theme';
import { SwipeableNoteCard, NoteCardSkeleton, FormattedText } from '@/components';
import { FAB } from '@/components/FAB';
import { EmptyState } from '@/components/EmptyState';
import { NoteActionsSheet } from '@/components/NoteActionsSheet';
import { getBackgroundById } from '@/components/BackgroundPicker';
import { useNotes } from '@/lib/NotesContext';
import { useToast } from '@/lib/ToastContext';
import { ViewMode, Note, SortBy, Category } from '@/types';

const Tab = createMaterialTopTabNavigator();

// Tab content component
function CategoryTabContent({
  categoryId,
  viewMode,
  sortBy,
  onNotePress,
  onNoteMenu,
  onDeleteNote,
  onArchiveNote,
  onRefresh,
}: {
  categoryId: string | null;
  viewMode: ViewMode;
  sortBy: SortBy;
  onNotePress: (id: string) => void;
  onNoteMenu: (id: string) => void;
  onDeleteNote: (note: Note) => void;
  onArchiveNote: (id: string) => void;
  onRefresh: () => Promise<void>;
}) {
  const { notes } = useNotes();
  const [refreshing, setRefreshing] = useState(false);

  const filteredNotes = useMemo(() => {
    const filtered = notes.filter((note) => {
      if (note.is_deleted || note.is_archived) return false;
      if (!categoryId || categoryId === 'all') return true;
      return note.category_id === categoryId;
    });

    // Sort: favorites first, then by selected sort option
    return filtered.sort((a, b) => {
      if (a.is_favorite && !b.is_favorite) return -1;
      if (!a.is_favorite && b.is_favorite) return 1;

      if (sortBy === 'title') {
        return a.title.toLowerCase().localeCompare(b.title.toLowerCase());
      } else if (sortBy === 'created') {
        return new Date(b.created_at).getTime() - new Date(a.created_at).getTime();
      } else {
        return new Date(b.updated_at).getTime() - new Date(a.updated_at).getTime();
      }
    });
  }, [notes, categoryId, sortBy]);

  const handleRefresh = useCallback(async () => {
    setRefreshing(true);
    await onRefresh();
    setRefreshing(false);
  }, [onRefresh]);

  const handleCreateNote = () => {
    router.push('/note/new');
  };

  const handleNotePress = (noteId: string) => {
    router.push(`/note/${noteId}`);
  };

  const handleNoteMenu = (noteId: string) => {
    const note = notes.find((n) => n.id === noteId);
    if (note) {
      setSelectedNote(note);
      setShowActionsSheet(true);
    }
  };

  const handleFavorite = async () => {
    if (selectedNote) {
      const wasFavorite = selectedNote.is_favorite;
      await toggleFavorite(selectedNote.id);
      showSuccess(wasFavorite ? 'Removed from favorites' : 'Added to favorites');
    }
  };

  const handleArchive = async () => {
    if (selectedNote) {
      const wasArchived = selectedNote.is_archived;
      await toggleArchive(selectedNote.id);
      showSuccess(wasArchived ? 'Note unarchived' : 'Note archived');
    }
  };

  const handleDelete = async () => {
    if (!selectedNote) return;

    Alert.alert(
      'Delete Note',
      'Are you sure you want to delete this note? It will be moved to trash.',
      [
        {
          text: 'Cancel',
          style: 'cancel',
        },
        {
          text: 'Delete',
          style: 'destructive',
          onPress: async () => {
            await deleteNote(selectedNote.id);
            setShowActionsSheet(false);
            showSuccess('Note moved to trash');
          },
        },
      ]
    );
  };

  const handleRefresh = async () => {
    setRefreshing(true);
    await refreshNotes();
    setRefreshing(false);
  };

  const handleColorChange = async (color: string | null) => {
    if (selectedNote) {
      await updateNote(selectedNote.id, { color });
      showSuccess('Note color updated');
    }
  };

  if (loading) {
    return (
      <View style={[styles.container, { paddingTop: insets.top }]}>
        <View style={styles.header}>
          <View style={styles.headerLeft}>
            <Menu size={24} color={Colors.light.text} />
            <Text style={styles.headerTitle}>Notes</Text>
          </View>
        </View>
        <ScrollView
          horizontal
          showsHorizontalScrollIndicator={false}
          style={styles.categoriesContainer}
          contentContainerStyle={styles.categoriesContent}
        >
          {[1, 2, 3, 4].map((i) => (
            <View key={i} style={styles.categorySkeleton} />
          ))}
        </ScrollView>
        <View style={styles.notesContainer}>
          {[1, 2, 3, 4, 5].map((i) => (
            <NoteCardSkeleton key={i} />
          ))}
        </View>
      </View>
    );
  }

  if (error) {
    return (
      <View style={[styles.container, { paddingTop: insets.top }]}>
        <View style={styles.header}>
          <View style={styles.headerLeft}>
            <Menu size={24} color={Colors.light.text} />
            <Text style={styles.headerTitle}>Notes</Text>
          </View>
        </View>
        <EmptyState
          title="Something went wrong"
          message={error}
          actionText="Try Again"
          onActionPress={retry}
        />
      </View>
    );
  }

  return (
    <View style={[styles.container, { paddingTop: insets.top }]}>
      <View style={styles.header}>
        <View style={styles.headerLeft}>
          <TouchableOpacity onPress={() => {}}>
            <Menu size={24} color={Colors.light.text} />
          </TouchableOpacity>
          <Text style={styles.headerTitle}>Notes</Text>
        </View>
        <View style={styles.headerRight}>
          <TouchableOpacity onPress={() => router.push('/search')} style={styles.iconButton}>
            <SearchIcon size={24} color={Colors.light.text} />
          </TouchableOpacity>
          <TouchableOpacity onPress={() => setShowSortModal(true)} style={styles.iconButton}>
            <ArrowUpDown size={24} color={Colors.light.text} />
          </TouchableOpacity>
          <TouchableOpacity
            onPress={() => setViewMode(viewMode === 'grid' ? 'list' : 'grid')}
            style={styles.iconButton}
          >
            {viewMode === 'grid' ? (
              <List size={24} color={Colors.light.text} />
            ) : (
              <Grid size={24} color={Colors.light.text} />
            )}
          </TouchableOpacity>
        </View>
      </View>

      <ScrollView
        horizontal
        showsHorizontalScrollIndicator={false}
        style={styles.categoriesContainer}
        contentContainerStyle={styles.categoriesContent}
      >
        {allCategories.map((category) => (
          <CategoryChip
            key={category.id}
            name={category.name}
            color={category.color}
            isActive={selectedCategory === category.id || (!selectedCategory && category.id === 'all')}
            onPress={() => setSelectedCategory(category.id)}
            noteCount={
              category.id === 'all'
                ? notes.filter((n) => !n.is_deleted && !n.is_archived).length
                : notes.filter((n) => n.category_id === category.id && !n.is_deleted && !n.is_archived).length
            }
          />
        ))}
      </ScrollView>

      {filteredNotes.length === 0 ? (
        <EmptyState
          title="No notes yet"
          message="Tap the + button to create your first note"
          actionText="Create Note"
          onActionPress={handleCreateNote}
        />
      ) : viewMode === 'list' ? (
        <FlatList
          key="list"
          data={filteredNotes}
          keyExtractor={(item) => item.id}
          renderItem={({ item }) => (
            <SwipeableNoteCard
              note={item}
              onPress={() => handleNotePress(item.id)}
              onMenuPress={() => handleNoteMenu(item.id)}
              onDelete={() => {
                setSelectedNote(item);
                handleDelete();
              }}
              onArchive={async () => {
                await toggleArchive(item.id);
              }}
            />
          )}
          contentContainerStyle={styles.notesContainer}
          showsVerticalScrollIndicator={false}
          refreshControl={
            <RefreshControl
              refreshing={refreshing}
              onRefresh={handleRefresh}
              colors={[Colors.light.primary]}
              tintColor={Colors.light.primary}
            />
          }
          removeClippedSubviews={true}
          maxToRenderPerBatch={10}
          windowSize={10}
          initialNumToRender={10}
          updateCellsBatchingPeriod={50}
        />
      ) : (
        <FlatList
          key="grid"
          data={filteredNotes}
          keyExtractor={(item) => item.id}
          numColumns={2}
          renderItem={({ item }) => {
            const background = getBackgroundById(item.color);
            const isGradient = background?.type === 'gradient' && background.gradient && background.gradient.length >= 2;
            const isPattern = background?.type === 'pattern';
            const isSolid = background?.type === 'solid' && background.value;

            const cardContent = (
              <>
                <View style={styles.gridContent}>
                  {item.is_favorite && (
                    <View style={styles.gridFavorite}>
                      <Text style={styles.gridFavoriteIcon}>‚≠ê</Text>
                    </View>
                  )}
                  {item.title ? (
                    <Text style={styles.gridTitle} numberOfLines={3}>
                      {item.title}
                    </Text>
                  ) : null}
                  {item.checklist_items && item.checklist_items.length > 0 ? (
                    <View style={styles.gridChecklist}>
                      {item.checklist_items.slice(0, 3).map((checkItem) => (
                        <View key={checkItem.id} style={styles.gridChecklistItem}>
                          <Text style={styles.gridChecklistIcon}>
                            {checkItem.completed ? '‚òë' : '‚òê'}
                          </Text>
                          <Text
                            style={[
                              styles.gridChecklistText,
                              checkItem.completed && styles.gridChecklistTextCompleted,
                            ]}
                            numberOfLines={1}
                          >
                            {checkItem.text || 'Empty'}
                          </Text>
                        </View>
                      ))}
                    </View>
                  ) : item.body ? (
                    <FormattedText
                      text={item.body.substring(0, 150) + (item.body.length > 150 ? '...' : '')}
                      style={styles.gridBody}
                      numberOfLines={6}
                    />
                  ) : null}
                </View>
                <TouchableOpacity
                  onPress={() => handleNoteMenu(item.id)}
                  style={styles.gridMenu}
                  hitSlop={{ top: 10, bottom: 10, left: 10, right: 10 }}
                >
                  <Text style={styles.gridMenuIcon}>‚ãÆ</Text>
                </TouchableOpacity>
                {isPattern && background?.pattern === 'grid' && (
                  <View style={styles.gridPatternOverlay} />
                )}
                {isPattern && background?.pattern === 'floral' && (
                  <Text style={styles.patternEmojiOverlay}>üå∏</Text>
                )}
                {isPattern && background?.pattern === 'strawberry' && (
                  <Text style={styles.patternEmojiOverlay}>üçì</Text>
                )}
              </>
            );

            return (
              <View style={styles.gridItem}>
                {isGradient ? (
                  <TouchableOpacity onPress={() => handleNotePress(item.id)} activeOpacity={0.7}>
                    <LinearGradient
                      colors={background.gradient as [string, string, ...string[]]}
                      style={styles.gridCard}
                      start={{ x: 0, y: 0 }}
                      end={{ x: 1, y: 1 }}
                    >
                      {cardContent}
                    </LinearGradient>
                  </TouchableOpacity>
                ) : (
                  <TouchableOpacity
                    style={[
                      styles.gridCard,
                      (isSolid || isPattern) && { backgroundColor: background?.value || Colors.light.surface }
                    ]}
                    onPress={() => handleNotePress(item.id)}
                    activeOpacity={0.7}
                  >
                    {cardContent}
                  </TouchableOpacity>
                )}
              </View>
            );
          }}
          contentContainerStyle={styles.gridContainer}
          showsVerticalScrollIndicator={false}
          refreshControl={
            <RefreshControl
              refreshing={refreshing}
              onRefresh={handleRefresh}
              colors={[Colors.light.primary]}
              tintColor={Colors.light.primary}
            />
          }
          removeClippedSubviews={true}
          maxToRenderPerBatch={10}
          windowSize={10}
          initialNumToRender={10}
          updateCellsBatchingPeriod={50}
        />
      )}

      <FAB onPress={handleCreateNote} />

      <NoteActionsSheet
        visible={showActionsSheet}
        note={selectedNote}
        onClose={() => setShowActionsSheet(false)}
        onFavorite={handleFavorite}
        onArchive={handleArchive}
        onDelete={handleDelete}
        onColorChange={handleColorChange}
      />

      <Modal
        visible={showSortModal}
        transparent
        animationType="fade"
        onRequestClose={() => setShowSortModal(false)}
        statusBarTranslucent
      >
        <Pressable style={styles.sortModalOverlay} onPress={() => setShowSortModal(false)}>
          <Pressable style={styles.sortModal} onPress={(e) => e.stopPropagation()}>
            <Text style={styles.sortModalTitle}>Sort by</Text>
            <TouchableOpacity
              style={styles.sortOption}
              onPress={() => {
                setSortBy('updated');
                setShowSortModal(false);
              }}
            >
              <Text style={styles.sortOptionText}>Last updated</Text>
              {sortBy === 'updated' && <Check size={20} color={Colors.light.primary} />}
            </TouchableOpacity>
            <TouchableOpacity
              style={styles.sortOption}
              onPress={() => {
                setSortBy('created');
                setShowSortModal(false);
              }}
            >
              <Text style={styles.sortOptionText}>Date created</Text>
              {sortBy === 'created' && <Check size={20} color={Colors.light.primary} />}
            </TouchableOpacity>
            <TouchableOpacity
              style={styles.sortOption}
              onPress={() => {
                setSortBy('title');
                setShowSortModal(false);
              }}
            >
              <Text style={styles.sortOptionText}>Title (A-Z)</Text>
              {sortBy === 'title' && <Check size={20} color={Colors.light.primary} />}
            </TouchableOpacity>
          </Pressable>
        </Pressable>
      </Modal>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: Colors.light.background,
  },
  header: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingHorizontal: Spacing.base,
    paddingVertical: Spacing.md,
    backgroundColor: Colors.light.surface,
    borderBottomWidth: 1,
    borderBottomColor: Colors.light.border,
  },
  headerLeft: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: Spacing.md,
  },
  headerTitle: {
    fontSize: Typography.fontSize.xl,
    fontWeight: Typography.fontWeight.bold,
    color: Colors.light.text,
  },
  headerRight: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: Spacing.sm,
  },
  iconButton: {
    padding: Spacing.xs,
  },
  categoriesContainer: {
    maxHeight: 50,
    backgroundColor: Colors.light.background,
    borderBottomWidth: 1,
    borderBottomColor: Colors.light.borderLight,
  },
  categoriesContent: {
    paddingHorizontal: Spacing.base,
    paddingVertical: Spacing.sm,
  },
  notesContainer: {
    padding: Spacing.base,
    paddingBottom: 100, // Generous padding to account for tab bar + safe area
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    gap: Spacing.md,
  },
  loadingText: {
    fontSize: Typography.fontSize.base,
    color: Colors.light.textSecondary,
  },
  categorySkeleton: {
    width: 80,
    height: 36,
    borderRadius: BorderRadius.xxl,
    backgroundColor: Colors.light.borderLight,
    marginRight: Spacing.sm,
  },
  sortModalOverlay: {
    flex: 1,
    backgroundColor: Colors.light.overlay,
    justifyContent: 'flex-end',
  },
  sortModal: {
    backgroundColor: Colors.light.surface,
    borderTopLeftRadius: BorderRadius.xxl,
    borderTopRightRadius: BorderRadius.xxl,
    paddingHorizontal: Spacing.xl,
    paddingTop: Spacing.xl,
    paddingBottom: Spacing.xxxl,
    ...Shadows.xl,
  },
  sortModalTitle: {
    fontSize: Typography.fontSize.lg,
    fontWeight: Typography.fontWeight.semibold,
    color: Colors.light.text,
    marginBottom: Spacing.base,
  },
  sortOption: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingVertical: Spacing.md,
    borderBottomWidth: 1,
    borderBottomColor: Colors.light.borderLight,
  },
  sortOptionText: {
    fontSize: Typography.fontSize.base,
    color: Colors.light.text,
  },
  gridContainer: {
    padding: Spacing.sm,
    paddingBottom: 100,
  },
  gridItem: {
    flex: 1,
    maxWidth: '50%',
    padding: Spacing.xs,
  },
  gridCard: {
    backgroundColor: Colors.light.surface,
    borderRadius: BorderRadius.lg,
    padding: Spacing.md,
    minHeight: 140,
    ...Shadows.md,
  },
  gridContent: {
    flex: 1,
    gap: Spacing.xs,
  },
  gridFavorite: {
    alignSelf: 'flex-end',
  },
  gridFavoriteIcon: {
    fontSize: 14,
  },
  gridTitle: {
    fontSize: Typography.fontSize.base,
    fontWeight: Typography.fontWeight.semibold,
    color: Colors.light.text,
    lineHeight: Typography.fontSize.base * Typography.lineHeight.tight,
  },
  gridBody: {
    fontSize: Typography.fontSize.sm,
    color: Colors.light.textSecondary,
    lineHeight: Typography.fontSize.sm * Typography.lineHeight.normal,
  },
  gridMenu: {
    position: 'absolute',
    bottom: Spacing.sm,
    right: Spacing.sm,
  },
  gridMenuIcon: {
    fontSize: 20,
    color: Colors.light.textTertiary,
    fontWeight: Typography.fontWeight.bold,
  },
  gridChecklist: {
    gap: 2,
  },
  gridChecklistItem: {
    flexDirection: 'row',
    alignItems: 'center',
    gap: Spacing.xs,
  },
  gridChecklistIcon: {
    fontSize: 12,
    color: Colors.light.textSecondary,
  },
  gridChecklistText: {
    flex: 1,
    fontSize: Typography.fontSize.xs,
    color: Colors.light.text,
  },
  gridChecklistTextCompleted: {
    textDecorationLine: 'line-through',
    color: Colors.light.textSecondary,
  },
  gridPatternOverlay: {
    position: 'absolute',
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    borderWidth: 1,
    borderColor: 'rgba(0,0,0,0.05)',
    borderStyle: 'solid',
    borderRadius: BorderRadius.lg,
  },
  patternEmojiOverlay: {
    position: 'absolute',
    top: '50%',
    left: '50%',
    fontSize: 60,
    opacity: 0.1,
    transform: [{ translateX: -30 }, { translateY: -30 }],
  },
});
